```
import sys
X, n = int(sys.stdin.readline()), 1
while (n * (n + 1)) // 2 < X:
    n += 1
cir, cirWls = (((n - 1) * n) // 2), (n * (n + 1) // 2)
if n % 2 == 0:print(str(X - cir) + '/' + str(cirWls - X + 1)) 
else:print(str(cirWls - X + 1) + '/' + str(X - cir))
```

### 성능 요약

메모리:   31256KB, 시간: 40ms 

(23.05.05 기준 시간 복잡도 순위 :20899/43788)



### 나의 풀이

1. 쉬웠다.

1. 우선 규칙성을 2가지 찾았다.
   1. 대각선 방향으로 개수가 1씩 증가한다

   1. 대각선이 짝수일 때 위에서 아래로, 홀수일 때 아래에서 위로 탐색한다.

1. 이를 해결하기 위해, 직접 탐색하기 보다는 시그마 공식을 이용하여 시간복잡도를 줄였다.

1. 또한 시간복잡도를 줄이기 위해 극단적으로 line 수를 줄였다.

1. 알게된 점
   1. 라인 수를 줄여가며 실행시간을 확인해보니, 정말 같은 내용이라도 라인 수가 적을수록 실행속도가 빨랐다.

   1.  확실히 수학적인 공식을 직접 적용하니 빨랐다



### 분류

- [수학](https://www.acmicpc.net/problem/tag/124)
- [구현](https://www.acmicpc.net/problem/tag/102)

### 문제 설명

1. 무한히 큰 배열에 다음과 같이 분수들이 적혀있다.

   | 1/1  | 1/2  | 1/3  | 1/4  | 1/5  | …    |
   | ---- | ---- | ---- | ---- | ---- | ---- |
   | 2/1  | 2/2  | 2/3  | 2/4  | …    | …    |
   | 3/1  | 3/2  | 3/3  | …    | …    | …    |
   | 4/1  | 4/2  | …    | …    | …    | …    |
   | 5/1  | …    | …    | …    | …    | …    |
   | …    | …    | …    | …    | …    | …    |

   이와 같이 나열된 분수들을 1/1 → 1/2 → 2/1 → 3/1 → 2/2 → … 과 같은 지그재그 순서로 차례대로 1번, 2번, 3번, 4번, 5번, … 분수라고 하자.

   X가 주어졌을 때, X번째 분수를 구하는 프로그램을 작성하시오.

### 입력

첫째 줄에 X(1 ≤ X ≤ 10,000,000)가 주어진다.

### 출력

첫째 줄에 분수를 출력한다.