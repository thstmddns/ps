```
import sys
stack = []
ss = sys.stdin.readline().rstrip()
s = sys.stdin.readline().rstrip()
for i in ss:
    stack.append(i)
    if i == stack[-1] and ''.join(stack[-len(s):]) == s:del stack[-len(s):]
f = ''.join(stack)
print(f) if stack else print('FRULA')
```

### 성능 요약

메모리:   194416KB, 시간:532ms 

(23.06.14 기준 시간 복잡도 순위 :8323/11145)



### 나의 풀이

1. 골드 4치곤 어렵지 않았다.
2. 스택에 차곡차곡 넣어가며 매번 폭발문자 길이만큼 비교한다.
3. 그 이유는 문자열 삭제 후 이미 지나간 문자와 조합하여 또 삭제할 수 있기 때문이다.
4.  알게 된점
   1. 뒤에서부터 비교할 때  -길이만큼 하면된다는 아이디어를 얻었다.




### 분류

- [자료 구조](https://www.acmicpc.net/problem/tag/175)
- [문자열](https://www.acmicpc.net/problem/tag/158)
- [스택](https://www.acmicpc.net/problem/tag/71)

### 문제 설명

1. 상근이는 문자열에 폭발 문자열을 심어 놓았다. 폭발 문자열이 폭발하면 그 문자는 문자열에서 사라지며, 남은 문자열은 합쳐지게 된다.

   폭발은 다음과 같은 과정으로 진행된다.

   - 문자열이 폭발 문자열을 포함하고 있는 경우에, 모든 폭발 문자열이 폭발하게 된다. 남은 문자열을 순서대로 이어 붙여 새로운 문자열을 만든다.
   - 새로 생긴 문자열에 폭발 문자열이 포함되어 있을 수도 있다.
   - 폭발은 폭발 문자열이 문자열에 없을 때까지 계속된다.

   상근이는 모든 폭발이 끝난 후에 어떤 문자열이 남는지 구해보려고 한다. 남아있는 문자가 없는 경우가 있다. 이때는 "FRULA"를 출력한다.

   폭발 문자열은 같은 문자를 두 개 이상 포함하지 않는다.


### 입력

첫째 줄에 문자열이 주어진다. 문자열의 길이는 1보다 크거나 같고, 1,000,000보다 작거나 같다.

둘째 줄에 폭발 문자열이 주어진다. 길이는 1보다 크거나 같고, 36보다 작거나 같다.

두 문자열은 모두 알파벳 소문자와 대문자, 숫자 0, 1, ..., 9로만 이루어져 있다.

### 출력

첫째 줄에 모든 폭발이 끝난 후 남은 문자열을 출력한다.